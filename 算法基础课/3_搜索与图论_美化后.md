---
date: 2025-10-21T22:01:00
tags:
  - C++
  - Algorithm
  - Graph Theory
  - Search
---


# ğŸ“ AcWingâ€”â€”ç®—æ³•åŸºç¡€è¯¾



![Language](https://img.shields.io/badge/Language-C%2B%2B-00599C?style=flat-square&logo=c%2B%2B)
![Topic](https://img.shields.io/badge/Topic-Graph%20%26%20Search-orange?style=flat-square)
![License](https://img.shields.io/badge/License-MIT-lightgrey?style=flat-square)
![Updated](https://img.shields.io/badge/Updated-2025--10--22-lightgrey?style=flat-square)

> ç¬¬ä¸‰è®² Â· æœç´¢ä¸å›¾è®º Â· DFS / BFS / æœ€çŸ­è·¯ / æœ€å°ç”Ÿæˆæ ‘

---

## ğŸ“– ç¬¬ä¸‰è®² æœç´¢ä¸å›¾è®º

### ğŸŒ² 1. DFS (æ·±åº¦ä¼˜å…ˆæœç´¢)

> **æ ¸å¿ƒæ€æƒ³**ï¼šDFS æ˜¯ä¸€ç§ç”¨äºéå†æˆ–æœç´¢æ ‘æˆ–å›¾çš„ç®—æ³•ã€‚å®ƒä»ä¸€ä¸ªèµ·å§‹èŠ‚ç‚¹å¼€å§‹ï¼Œæ²¿ç€ä¸€æ¡è·¯å¾„å°½å¯èƒ½æ·±åœ°æ¢ç´¢ï¼Œç›´åˆ°åˆ°è¾¾æœ«ç«¯ï¼Œç„¶åå›æº¯åˆ°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼Œé€‰æ‹©å¦ä¸€æ¡æœªè¢«è®¿é—®çš„è·¯å¾„ç»§ç»­æ¢ç´¢ã€‚DFS é€šå¸¸ä½¿ç”¨é€’å½’æˆ–æ˜¾å¼æ ˆæ¥å®ç°ï¼Œå…¶æ ¸å¿ƒåœ¨äº **â€œä¸æ’å—å¢™ä¸å›å¤´â€** çš„æ¢ç´¢æ–¹å¼å’Œ **â€œæ¢å¤ç°åœºâ€** çš„å›æº¯æ€æƒ³ã€‚

#### 1.1 æ’åˆ—æ•°å­—
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240130161746893](assets/image-20240130161746893.png)

> **è§£æ³•æ€è·¯**ï¼šè¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„å…¨æ’åˆ—é—®é¢˜ã€‚æˆ‘ä»¬ä½¿ç”¨ DFS æ¥æ¢ç´¢æ‰€æœ‰å¯èƒ½çš„æ’åˆ—ã€‚`dfs(u)` å‡½æ•°è¡¨ç¤ºæ­£åœ¨ç¡®å®šæ’åˆ—çš„ç¬¬ `u` ä¸ªä½ç½®ã€‚æˆ‘ä»¬éå†æ•°å­— 1 åˆ° nï¼Œå¦‚æœä¸€ä¸ªæ•°å­— `i` å°šæœªè¢«ä½¿ç”¨ï¼ˆé€šè¿‡ `st` æ•°ç»„åˆ¤æ–­ï¼‰ï¼Œå°±å°†å®ƒæ”¾åœ¨ç¬¬ `u` ä½ï¼Œæ ‡è®°ä¸ºå·²ç”¨ï¼Œç„¶åé€’å½’åˆ°ä¸‹ä¸€å±‚ `dfs(u + 1)`ã€‚å½“ `u > n` æ—¶ï¼Œè¡¨ç¤ºä¸€ä¸ªå®Œæ•´çš„æ’åˆ—å·²ç”Ÿæˆï¼Œè¾“å‡ºå³å¯ã€‚ä¹‹åï¼Œ**å›æº¯**ï¼Œå–æ¶ˆå¯¹æ•°å­— `i` çš„ä½¿ç”¨æ ‡è®°ï¼Œä»¥ä¾¿å…¶ä»–åˆ†æ”¯å¯ä»¥ä½¿ç”¨å®ƒã€‚

```cpp
#include<iostream>
using namespace std;
const int N = 10;

int path[N];    // ä¿å­˜å½“å‰æ’åˆ—
bool st[N];     // æ ‡è®°æ•°å­—æ˜¯å¦å·²è¢«ä½¿ç”¨
int n;

void dfs(int u) {
    // å¦‚æœ u è¶…è¿‡ nï¼Œè¯´æ˜ä¸€ä¸ª n ä½æ•°çš„æ’åˆ—å·²ç»ç”Ÿæˆå®Œæ¯•
    if (u > n) {
        for (int i = 1; i <= n; i++) {
            cout << path[i] << " ";
        }
        cout << endl;
        return;
    }

    // éå†æ‰€æœ‰æ•°å­—ï¼Œå°è¯•å°†å…¶æ”¾å…¥ç¬¬ u ä¸ªä½ç½®
    for (int i = 1; i <= n; i++) {
        if (!st[i]) { // å¦‚æœæ•°å­— i æ²¡è¢«ç”¨è¿‡
            path[u] = i;        // æ”¾ç½®æ•°å­—
            st[i] = true;       // æ ‡è®°ä¸ºå·²ç”¨
            dfs(u + 1);         // é€’å½’åˆ°ä¸‹ä¸€ä¸ªä½ç½®
            
            // å›æº¯ï¼šæ¢å¤ç°åœºï¼Œä»¥ä¾¿å…¶ä»–åˆ†æ”¯å¯ä»¥ç»§ç»­æœç´¢
            st[i] = false;
        }
    }
}

int main() {
    cin >> n;
    dfs(1);
    return 0;
}
```
</details>

#### 1.2 n-çš‡åé—®é¢˜
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240131095222180](assets/image-20240131095222180.png)

> **è§£æ³•æ€è·¯**ï¼šæŒ‰è¡Œè¿›è¡Œ DFS æœç´¢ã€‚`dfs(row)` è¡¨ç¤ºåœ¨ç¬¬ `row` è¡Œæ”¾ç½®çš‡åã€‚æˆ‘ä»¬éå†è¯¥è¡Œçš„æ¯ä¸€åˆ— `col`ï¼Œæ£€æŸ¥è¯¥ä½ç½® `(row, col)` æ˜¯å¦ä¸ä¹‹å‰æ”¾ç½®çš„çš‡åå†²çªã€‚ä¸ºäº†é«˜æ•ˆåˆ¤æ–­å†²çªï¼Œä½¿ç”¨ä¸‰ä¸ªå¸ƒå°”æ•°ç»„ `col[]`, `dg[]`, `udg[]` åˆ†åˆ«æ ‡è®°æŸä¸€åˆ—ã€ä¸»å¯¹è§’çº¿ã€å‰¯å¯¹è§’çº¿æ˜¯å¦å·²è¢«å ç”¨ã€‚
> -   åˆ—å†²çªï¼š`col[c]`
> -   ä¸»å¯¹è§’çº¿å†²çª (y=x+b => b=y-x): `dg[row - col]`
> -   å‰¯å¯¹è§’çº¿å†²çª (y=-x+b => b=y+x): `udg[row + col]`
>
> å¦‚æœä¸å†²çªï¼Œåˆ™æ”¾ç½®çš‡åï¼Œæ ‡è®°å ç”¨ï¼Œå¹¶é€’å½’åˆ°ä¸‹ä¸€è¡Œ `dfs(row + 1)`ã€‚ä¹‹åå›æº¯ï¼Œå–æ¶ˆæ ‡è®°ã€‚

```cpp
#include <iostream>
using namespace std;
const int N = 20;

int n;
char g[N][N];
bool col[N], dg[N*2], udg[N*2]; // å¯¹è§’çº¿æ•°ç»„å¤§å°éœ€è¦2N

// æŒ‰è¡Œæœç´¢
void dfs(int r) {
    if (r == n) {
        for (int i = 0; i < n; i++) puts(g[i]);
        puts("");
        return;
    }

    // éå†å½“å‰è¡Œçš„æ¯ä¸€åˆ—
    for (int c = 0; c < n; c++) {
        // å‰ªæï¼šæ£€æŸ¥åˆ—ã€ä¸»å¯¹è§’çº¿ã€å‰¯å¯¹è§’çº¿æ˜¯å¦å†²çª
        if (!col[c] && !dg[r - c + n] && !udg[r + c]) {
            g[r][c] = 'Q';
            col[c] = dg[r - c + n] = udg[r + c] = true;
            dfs(r + 1);
            // å›æº¯
            col[c] = dg[r - c + n] = udg[r + c] = false;
            g[r][c] = '.';
        }
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            g[i][j] = '.';
        }
    }
    dfs(0);
    return 0;
}
```
</details>

---

### ğŸŒŠ 2. BFS (å¹¿åº¦ä¼˜å…ˆæœç´¢)

> **æ ¸å¿ƒæ€æƒ³**ï¼šBFS ä¹Ÿæ˜¯ä¸€ç§å›¾/æ ‘çš„éå†ç®—æ³•ã€‚å®ƒä»èµ·å§‹èŠ‚ç‚¹å¼€å§‹ï¼Œé¦–å…ˆè®¿é—®å…¶æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹ï¼Œç„¶åé€å±‚å‘å¤–æ‰©å±•ï¼Œå…ˆè®¿é—®å®Œè·ç¦»ä¸º k çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå†è®¿é—®è·ç¦»ä¸º k+1 çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚BFS é€šå¸¸ä½¿ç”¨é˜Ÿåˆ—æ¥å®ç°ï¼Œéå¸¸é€‚åˆè§£å†³ **æœ€çŸ­è·¯å¾„**ï¼ˆåœ¨æ— æƒå›¾ä¸­ï¼‰æˆ– **æœ€å°‘æ“ä½œæ¬¡æ•°** çš„é—®é¢˜ï¼Œå› ä¸ºå®ƒèƒ½ä¿è¯æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªè§£å°±æ˜¯æœ€ä¼˜è§£ã€‚

#### 2.1 èµ°è¿·å®«
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240131143848023](assets/image-20240131143848023.png)

> **è§£æ³•æ€è·¯**ï¼šè¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„æ— æƒå›¾æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œä½¿ç”¨ BFS è§£å†³ã€‚æˆ‘ä»¬ç”¨ä¸€ä¸ªé˜Ÿåˆ— `q` å­˜å‚¨å¾…è®¿é—®çš„åæ ‡ `(x, y)`ï¼Œç”¨ä¸€ä¸ªè·ç¦»æ•°ç»„ `d[x][y]` å­˜å‚¨ä»èµ·ç‚¹ `(0, 0)` åˆ° `(x, y)` çš„æœ€çŸ­è·ç¦»ã€‚
> 1.  å°†èµ·ç‚¹ `(0, 0)` å…¥é˜Ÿï¼Œ`d[0][0] = 0`ã€‚
> 2.  å½“é˜Ÿåˆ—ä¸ç©ºæ—¶ï¼Œå–å‡ºé˜Ÿå¤´ `t`ï¼Œéå†å…¶ä¸Šä¸‹å·¦å³å››ä¸ªç›¸é‚»ç‚¹ `(nx, ny)`ã€‚
> 3.  å¦‚æœ `(nx, ny)` å¯è¾¾ï¼ˆæœªè¶Šç•Œã€ééšœç¢ç‰©ï¼‰ä¸” **æœªè¢«è®¿é—®è¿‡**ï¼ˆ`d[nx][ny] == -1`ï¼‰ï¼Œåˆ™æ›´æ–°å…¶è·ç¦» `d[nx][ny] = d[t.x][t.y] + 1`ï¼Œå¹¶å°†å…¶å…¥é˜Ÿã€‚
> 4.  é‡å¤æ­¤è¿‡ç¨‹ï¼Œç›´åˆ°ç»ˆç‚¹è¢«è®¿é—®æˆ–é˜Ÿåˆ—ä¸ºç©ºã€‚`d[n-1][m-1]` å³ä¸ºç­”æ¡ˆã€‚

```cpp
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
const int N = 110;

int n, m;
int g[N][N], d[N][N];

int bfs() {
    queue<PII> q;
    q.push({0, 0});
    
    memset(d, -1, sizeof d);
    d = 0;

    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};

    while (q.size()) {
        auto t = q.front();
        q.pop();

        if (t.first == n - 1 && t.second == m - 1) return d[t.first][t.second];

        for (int i = 0; i < 4; i++) {
            int x = t.first + dx[i], y = t.second + dy[i];
            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1) {
                d[x][y] = d[t.first][t.second] + 1;
                q.push({x, y});
            }
        }
    }
    return -1;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> g[i][j];
        }
    }
    cout << bfs() << endl;
    return 0;
}
```
</details>

#### 2.2 å…«æ•°ç 
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>
![image-20240131163524526](assets/image-20240131163524526.png)

> **è§£æ³•æ€è·¯**ï¼šå°†æ¯ä¸ªä¹å®«æ ¼çŠ¶æ€è§†ä¸ºä¸€ä¸ªèŠ‚ç‚¹ï¼ŒçŠ¶æ€ä¹‹é—´çš„è½¬æ¢ï¼ˆç§»åŠ¨ 'x'ï¼‰è§†ä¸ºè¾¹ï¼Œé—®é¢˜è½¬åŒ–ä¸ºæ±‚ä»åˆå§‹çŠ¶æ€åˆ°ç›®æ ‡çŠ¶æ€ `12345678x` çš„æœ€çŸ­è·¯å¾„ã€‚
> -   **çŠ¶æ€è¡¨ç¤º**ï¼šç”¨å­—ç¬¦ä¸²è¡¨ç¤ºä¹å®«æ ¼çŠ¶æ€ã€‚
> -   **BFS æ¡†æ¶**ï¼šä½¿ç”¨é˜Ÿåˆ— `q` å­˜å‚¨çŠ¶æ€å­—ç¬¦ä¸²ï¼Œä½¿ç”¨ `unordered_map<string, int> d` å­˜å‚¨æ¯ä¸ªçŠ¶æ€çš„è·ç¦»ï¼ˆæ“ä½œæ¬¡æ•°ï¼‰å¹¶å…¼åšåˆ¤é‡ã€‚
> -   **çŠ¶æ€è½¬ç§»**ï¼šæ¯æ¬¡ä»é˜Ÿåˆ—å–å‡ºçŠ¶æ€ `t`ï¼Œæ‰¾åˆ° 'x' çš„ä½ç½®ï¼Œå°è¯•å°†å…¶ä¸ä¸Šä¸‹å·¦å³çš„æ•°å­—äº¤æ¢ï¼Œç”Ÿæˆæ–°çŠ¶æ€ `t_new`ã€‚å¦‚æœ `t_new` æœªè¢«è®¿é—®è¿‡ï¼Œåˆ™æ›´æ–°è·ç¦»å¹¶å…¥é˜Ÿã€‚

```cpp
#include <iostream>
#include <string>
#include <queue>
#include <unordered_map>
#include <algorithm>
using namespace std;

int bfs(string start) {
    string end = "12345678x";
    queue<string> q;
    unordered_map<string, int> d;

    q.push(start);
    d[start] = 0;

    int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};

    while (q.size()) {
        auto t = q.front();
        q.pop();

        if (t == end) return d[t];
        int dist = d[t];
        
        int k = t.find('x');
        int x = k / 3, y = k % 3;

        for (int i = 0; i < 4; i++) {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3) {
                string next_state = t;
                swap(next_state[k], next_state[a * 3 + b]);
                if (d.find(next_state) == d.end()) {
                    d[next_state] = dist + 1;
                    q.push(next_state);
                }
            }
        }
    }
    return -1;
}

int main() {
    string start = "";
    for (int i = 0; i < 9; i++) {
        char c;
        cin >> c;
        start += c;
    }
    cout << bfs(start) << endl;
    return 0;
}
```
</details>

---

### ğŸŒ³ 3. æ ‘ä¸å›¾çš„éå†

> **æ ¸å¿ƒæ€æƒ³**ï¼šæ— è®ºæ˜¯æ ‘è¿˜æ˜¯å›¾ï¼Œå…¶æœ¬è´¨éƒ½æ˜¯ç”±èŠ‚ç‚¹å’Œè¾¹æ„æˆçš„ç»“æ„ã€‚éå†æ˜¯æŒ‡ç³»ç»Ÿåœ°è®¿é—®å›¾ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ã€‚
> - **å­˜å‚¨æ–¹å¼**ï¼šå¸¸ç”¨é‚»æ¥çŸ©é˜µï¼ˆç¨ å¯†å›¾ï¼‰æˆ–é‚»æ¥è¡¨ï¼ˆç¨€ç–å›¾ï¼‰ã€‚æœ¬èŠ‚ä¸»è¦ä½¿ç”¨é‚»æ¥è¡¨ï¼ˆæ•°ç»„æ¨¡æ‹Ÿé“¾è¡¨ï¼‰ã€‚
> - **DFS éå†**ï¼šé€’å½’å®ç°ï¼Œæ·±å…¥æ¢ç´¢ã€‚`dfs(u)` è®¿é—®èŠ‚ç‚¹ `u`ï¼Œç„¶åå¯¹ `u` çš„æ¯ä¸ªæœªè®¿é—®è¿‡çš„é‚»å±… `v` è°ƒç”¨ `dfs(v)`ã€‚
> - **BFS éå†**ï¼šé˜Ÿåˆ—å®ç°ï¼Œé€å±‚æ‰©å±•ã€‚å°†èµ·ç‚¹å…¥é˜Ÿï¼Œç„¶åå¾ªç¯ï¼šå‡ºé˜ŸèŠ‚ç‚¹ `u`ï¼Œå°†å…¶æ‰€æœ‰æœªè®¿é—®è¿‡çš„é‚»å±…å…¥é˜Ÿå¹¶æ ‡è®°ã€‚

#### 3.1 æ ‘çš„é‡å¿ƒ
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240202144411302](assets/image-20240202144411302.png)

> **è§£æ³•æ€è·¯**ï¼šæ ‘çš„é‡å¿ƒæ˜¯æŒ‡ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ é™¤å®ƒä¹‹åï¼Œå‰©ä½™å„ä¸ªè¿é€šå—ä¸­èŠ‚ç‚¹æ•°çš„æœ€å¤§å€¼æœ€å°ã€‚
> 1.  å¯¹æ ‘è¿›è¡Œä¸€æ¬¡ DFS éå†ï¼Œä»ä»»æ„èŠ‚ç‚¹ï¼ˆå¦‚ 1ï¼‰å¼€å§‹ã€‚
> 2.  `dfs(u)` å‡½æ•°è¿”å›ä»¥ `u` ä¸ºæ ¹çš„å­æ ‘çš„èŠ‚ç‚¹æ€»æ•°ã€‚
> 3.  åœ¨ `dfs(u)` çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹äº `u` çš„æ¯ä¸ªå­èŠ‚ç‚¹ `j`ï¼Œæˆ‘ä»¬é€’å½’è°ƒç”¨ `dfs(j)` å¾—åˆ°å­æ ‘å¤§å° `s`ã€‚è¿™ä¸ª `s` å°±æ˜¯åˆ é™¤ `u` åå½¢æˆçš„ä¸€ä¸ªè¿é€šå—çš„å¤§å°ã€‚
> 4.  é™¤äº†è¿™äº›å­æ ‘å½¢æˆçš„è¿é€šå—ï¼Œè¿˜æœ‰ä¸€ä¸ªè¿é€šå—æ˜¯ `u` çš„çˆ¶èŠ‚ç‚¹æ‰€åœ¨çš„éƒ¨åˆ†ï¼Œå…¶å¤§å°ä¸º `n - (ä»¥uä¸ºæ ¹çš„å­æ ‘å¤§å°)`ã€‚
> 5.  å¯¹äºæ¯ä¸ªèŠ‚ç‚¹ `u`ï¼Œæˆ‘ä»¬è®¡ç®—å‡ºåˆ é™¤å®ƒåæ‰€æœ‰è¿é€šå—å¤§å°çš„æœ€å¤§å€¼ï¼Œå¹¶æ›´æ–°å…¨å±€æœ€å°å€¼ `ans`ã€‚

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 1e5 + 10, M = N * 2;

int h[N], e[M], ne[M], idx;
bool st[N];
int n, ans = N;

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

// è¿”å›ä»¥ u ä¸ºæ ¹çš„å­æ ‘å¤§å°
int dfs(int u) {
    st[u] = true;
    int sum = 1, max_part_size = 0;

    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!st[j]) {
            int s = dfs(j); // sæ˜¯å­æ ‘jçš„å¤§å°
            max_part_size = max(max_part_size, s);
            sum += s;
        }
    }
    
    // å¦ä¸€ä¸ªè¿é€šå—æ˜¯ u çš„çˆ¶èŠ‚ç‚¹éƒ¨åˆ†
    max_part_size = max(max_part_size, n - sum);
    ans = min(ans, max_part_size);
    
    return sum;
}

int main() {
    memset(h, -1, sizeof h);
    cin >> n;
    for (int i = 0; i < n - 1; i++) {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    dfs(1);
    cout << ans << endl;
    return 0;
}
```
</details>

#### 3.2 å›¾ä¸­ç‚¹çš„å±‚æ¬¡
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>
...

> **è§£æ³•æ€è·¯**ï¼šæ±‚æœ‰å‘å›¾ä¸­èŠ‚ç‚¹ 1 åˆ°èŠ‚ç‚¹ n çš„æœ€çŸ­è·ç¦»ã€‚ç”±äºæ˜¯æ— æƒå›¾ï¼Œè¾¹çš„é•¿åº¦éƒ½ä¸º 1ï¼Œå› æ­¤è¿™å°±æ˜¯ä¸€ä¸ªå…¸å‹çš„ BFS åº”ç”¨ã€‚

```cpp
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
const int N = 100010;

int h[N], e[N], ne[N], d[N], idx;
int n, m;

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

int bfs() {
    memset(d, -1, sizeof d);
    queue<int> q;
    
    q.push(1);
    d = 0;
    
    while(q.size()) {
        int t = q.front();
        q.pop();
        
        if (t == n) return d[n];
        
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (d[j] == -1) {
                d[j] = d[t] + 1;
                q.push(j);
            }
        }
    }
    return -1;
}

int main() {
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while (m--) {
        int a, b;
        cin >> a >> b;
        add(a, b);
    }
    cout << bfs() << endl;
    return 0;
}
```
</details>

---

### â¡ï¸ 4. æ‹“æ‰‘æ’åº

> **æ ¸å¿ƒæ€æƒ³**ï¼šæ‹“æ‰‘æ’åºæ˜¯å¯¹ **æœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰** çš„é¡¶ç‚¹è¿›è¡Œæ’åºï¼Œä½¿å¾—å¯¹äºå›¾ä¸­æ¯ä¸€æ¡æœ‰å‘è¾¹ `u -> v`ï¼ŒèŠ‚ç‚¹ `u` éƒ½å‡ºç°åœ¨èŠ‚ç‚¹ `v` ä¹‹å‰ã€‚
>
> **ç®—æ³•æµç¨‹ï¼ˆåŸºäº BFSï¼‰**ï¼š
> 1.  ç»Ÿè®¡æ‰€æœ‰èŠ‚ç‚¹çš„å…¥åº¦ `d[i]`ã€‚
> 2.  å°†æ‰€æœ‰å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—ã€‚
> 3.  å½“é˜Ÿåˆ—ä¸ç©ºæ—¶ï¼Œå‡ºé˜Ÿä¸€ä¸ªèŠ‚ç‚¹ `t`ï¼Œå°†å…¶åŠ å…¥æ‹“æ‰‘åºåˆ—ã€‚
> 4.  éå† `t` çš„æ‰€æœ‰å‡ºè¾¹ `t -> j`ï¼Œå°†èŠ‚ç‚¹ `j` çš„å…¥åº¦å‡ 1ã€‚
> 5.  å¦‚æœ `j` çš„å…¥åº¦å˜ä¸º 0ï¼Œåˆ™å°† `j` å…¥é˜Ÿã€‚
> 6.  å¾ªç¯ç»“æŸã€‚å¦‚æœæ‹“æ‰‘åºåˆ—ä¸­çš„èŠ‚ç‚¹æ•°ç­‰äºå›¾çš„æ€»èŠ‚ç‚¹æ•°ï¼Œåˆ™æ’åºæˆåŠŸï¼›å¦åˆ™ï¼Œå›¾ä¸­å­˜åœ¨ç¯ã€‚

#### 4.1 æœ‰å‘å›¾çš„æ‹“æ‰‘åºåˆ—
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240203114310300](assets/image-20240203114310300.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 100010;

int h[N], e[N], ne[N], idx;
int q[N], d[N]; // d[]æ˜¯å…¥åº¦æ•°ç»„, q[]æ˜¯é˜Ÿåˆ—
int n, m;

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool topsort() {
    int hh = 0, tt = -1;
    for (int i = 1; i <= n; i++) {
        if (!d[i]) q[++tt] = i;
    }

    while (hh <= tt) {
        int t = q[hh++];
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            d[j]--;
            if (d[j] == 0) q[++tt] = j;
        }
    }
    return tt == n - 1;
}

int main() {
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while (m--) {
        int a, b;
        cin >> a >> b;
        add(a, b);
        d[b]++;
    }
    if (topsort()) {
        for (int i = 0; i < n; i++) cout << q[i] << " ";
        cout << endl;
    } else {
        cout << -1 << endl;
    }
    return 0;
}
```
</details>

---

### ğŸ“ 5. æœ€çŸ­è·¯ç®—æ³•

#### 5.1 Dijkstra ç®—æ³•
> **æ ¸å¿ƒæ€æƒ³**ï¼šDijkstra æ˜¯ä¸€ç§è´ªå¿ƒç®—æ³•ï¼Œç”¨äºæ±‚è§£ **å•æºæœ€çŸ­è·¯å¾„** é—®é¢˜ï¼Œä½† **ä¸èƒ½å¤„ç†å¸¦è´Ÿæƒè¾¹çš„å›¾**ã€‚
> -   å®ƒç»´æŠ¤ä¸€ä¸ªå·²ç¡®å®šæœ€çŸ­è·¯å¾„çš„èŠ‚ç‚¹é›†åˆ `S`ï¼Œå’Œä¸€ä¸ªæœªç¡®å®šçš„é›†åˆ `U`ã€‚
> -   æ¯æ¬¡ä» `U` ä¸­é€‰æ‹©ä¸€ä¸ªè·ç¦»æºç‚¹æœ€è¿‘çš„èŠ‚ç‚¹ `t`ï¼ŒåŠ å…¥ `S`ã€‚
> -   ç”¨ `t` æ¥ â€œæ¾å¼›â€ `t` çš„æ‰€æœ‰é‚»å±… `j`ï¼Œå³æ›´æ–° `dist[j]` çš„å€¼ï¼š`dist[j] = min(dist[j], dist[t] + weight(t, j))`ã€‚
> -   **æœ´ç´ ç‰ˆ (O(nÂ²))**ï¼šé€‚ç”¨äºç¨ å¯†å›¾ï¼Œç”¨å¾ªç¯æŸ¥æ‰¾ `U` ä¸­æœ€è¿‘çš„ç‚¹ã€‚
> -   **å †ä¼˜åŒ–ç‰ˆ (O(m log n))**ï¼šé€‚ç”¨äºç¨€ç–å›¾ï¼Œç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰å¿«é€Ÿæ‰¾åˆ° `U` ä¸­æœ€è¿‘çš„ç‚¹ã€‚

<details>
<summary><strong>Dijkstra I (æœ´ç´ ç‰ˆ)</strong></summary>

![image-20240203150841562](assets/image-20240203150841562.png)

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 510;

int g[N][N];
int dist[N];
bool st[N];
int n, m;

int dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist = 0;

    for (int i = 0; i < n; i++) {
        int t = -1;
        // æ‰¾åˆ°æœªç¡®å®šä¸”è·ç¦»æœ€è¿‘çš„ç‚¹
        for (int j = 1; j <= n; j++) {
            if (!st[j] && (t == -1 || dist[t] > dist[j])) {
                t = j;
            }
        }
        
        st[t] = true;
        // ç”¨ t æ›´æ–°å…¶ä»–ç‚¹çš„è·ç¦»
        for (int j = 1; j <= n; j++) {
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main() {
    cin >> n >> m;
    memset(g, 0x3f, sizeof g);
    while(m--) {
        int x, y, z;
        cin >> x >> y >> z;
        g[x][y] = min(g[x][y], z);
    }
    cout << dijkstra() << endl;
    return 0;
}
```
</details>

<details>
<summary><strong>Dijkstra II (å †ä¼˜åŒ–ç‰ˆ)</strong></summary>

![image-20240204093023259](assets/image-20240204093023259.png)

```cpp
#include <cstring>
#include <iostream>
#include <queue>
#include <vector>
using namespace std;
typedef pair<int, int> PII;
const int N = 150010;

int n, m;
int h[N], w[N], e[N], ne[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1}); // {distance, node_id}

    while (heap.size()) {
        auto t = heap.top();
        heap.pop();
        int ver = t.second, distance = t.first;
        
        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > distance + w[i]) {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main() {
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    cout << dijkstra() << endl;
    return 0;
}
```
</details>

#### 5.2 Bellman-Ford & SPFA ç®—æ³•
> **æ ¸å¿ƒæ€æƒ³**:
> - **Bellman-Ford (O(nm))**: èƒ½å¤„ç† **å¸¦è´Ÿæƒè¾¹** çš„å•æºæœ€çŸ­è·¯ï¼Œå¹¶èƒ½ **æ£€æµ‹è´Ÿæƒç¯**ã€‚æ ¸å¿ƒæ˜¯å¾ªç¯ n-1 æ¬¡ï¼Œæ¯æ¬¡å¯¹æ‰€æœ‰ m æ¡è¾¹è¿›è¡Œæ¾å¼›æ“ä½œã€‚å¦‚æœç¬¬ n æ¬¡å¾ªç¯ä»èƒ½æ¾å¼›ï¼Œåˆ™å­˜åœ¨è´Ÿæƒç¯ã€‚
> - **SPFA (é€šå¸¸ O(m), æœ€å O(nm))**: Bellman-Ford çš„é˜Ÿåˆ—ä¼˜åŒ–ç‰ˆæœ¬ã€‚åªæœ‰è¢«æ¾å¼›è¿‡çš„èŠ‚ç‚¹ï¼Œå…¶é‚»å±…æ‰å¯èƒ½è¢«æ›´æ–°ï¼Œå› æ­¤åªå°†è¿™äº›è¢«æ¾å¼›çš„èŠ‚ç‚¹å…¥é˜Ÿï¼Œé¿å…äº†æ— æ•ˆçš„éå†ã€‚SPFA åŒæ ·èƒ½å¤„ç†è´Ÿæƒè¾¹å’Œæ£€æµ‹è´Ÿæƒç¯ï¼ˆé€šè¿‡è®°å½•ä¸€ä¸ªç‚¹å…¥é˜Ÿçš„æ¬¡æ•°æˆ–æœ€çŸ­è·¯å¾„çš„è¾¹æ•°ï¼‰ã€‚

<details>
<summary><strong>Bellman-Ford (æœ‰è¾¹æ•°é™åˆ¶çš„æœ€çŸ­è·¯)</strong></summary>

![image-20240204105709396](assets/image-20240204105709396.png)
> **æ³¨æ„**ï¼šå¸¸è§„ Bellman-Ford å¾ªç¯ `n-1` æ¬¡ï¼Œè¿™é‡Œé¢˜ç›®é™åˆ¶äº†æœ€å¤š `k` æ¡è¾¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾ªç¯ `k` æ¬¡ã€‚ä½¿ç”¨ `backup` æ•°ç»„æ˜¯ä¸ºäº†é˜²æ­¢åœ¨ä¸€æ¬¡è¿­ä»£ä¸­å‘ç”Ÿâ€œä¸²è”æ›´æ–°â€ï¼Œç¡®ä¿æ¯è½®è¿­ä»£åªä½¿ç”¨ä¸Šä¸€è½®çš„ç»“æœï¼Œä¸¥æ ¼å¯¹åº”â€œç»è¿‡è‡³å¤š i æ¡è¾¹çš„æœ€çŸ­è·¯â€ã€‚

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 510, M = 10010;

struct Edge {
    int a, b, w;
} edges[M];

int n, m, k;
int dist[N], backup[N];

void bellman_ford() {
    memset(dist, 0x3f, sizeof dist);
    dist = 0;

    for (int i = 0; i < k; i++) {
        memcpy(backup, dist, sizeof dist);
        for (int j = 0; j < m; j++) {
            auto e = edges[j];
            dist[e.b] = min(dist[e.b], backup[e.a] + e.w);
        }
    }
}

int main() {
    cin >> n >> m >> k;
    for (int i = 0; i < m; i++) {
        int a, b, w;
        cin >> a >> b >> w;
        edges[i] = {a, b, w};
    }
    bellman_ford();
    // å¦‚æœ dist[n] > INF / 2ï¼Œå¯èƒ½è¢«è´Ÿæƒè¾¹æ›´æ–°è¿‡ï¼Œä½†ä»ä¸å¯è¾¾
    if (dist[n] > 0x3f3f3f3f / 2) puts("impossible");
    else cout << dist[n] << endl;
    return 0;
}
```
</details>

<details>
<summary><strong>SPFA (æ±‚æœ€çŸ­è·¯)</strong></summary>

![image-20240204145128620](assets/image-20240204145128620.png)

```cpp
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
const int N = 100010;

int n, m;
int h[N], w[N], e[N], ne[N], idx;
int dist[N];
bool st[N]; // æ ‡è®°æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int spfa() {
    memset(dist, 0x3f, sizeof dist);
    dist = 0;
    queue<int> q;
    q.push(1);
    st = true;

    while (q.size()) {
        int t = q.front();
        q.pop();
        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return dist[n];
}

int main() {
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    int t = spfa();
    if (t == 0x3f3f3f3f) puts("impossible");
    else cout << t << endl;
    return 0;
}
```
</details>

<details>
<summary><strong>SPFA (åˆ¤æ–­è´Ÿç¯)</strong></summary>

![image-20240204152907404](assets/image-20240204152907404.png)
> **æ€è·¯**ï¼šè‹¥å­˜åœ¨è´Ÿç¯ï¼Œåˆ™ä»ç¯ä¸ŠæŸç‚¹å‡ºå‘ï¼Œç»•ç¯ä¸€åœˆåè·¯å¾„ä¼šå˜çŸ­ï¼Œå¯¼è‡´æ— é™æ¾å¼›ã€‚æˆ‘ä»¬ç”¨ `cnt[x]` è®°å½•ä»æºç‚¹åˆ° `x` çš„æœ€çŸ­è·¯å¾„æ‰€å«çš„è¾¹æ•°ã€‚è‹¥ `cnt[x] >= n`ï¼Œæ ¹æ®æŠ½å±‰åŸç†ï¼Œè·¯å¾„ä¸Šå¿…æœ‰é‡å¤ç‚¹ï¼Œå³å­˜åœ¨ç¯ã€‚ç”±äºæ˜¯è´Ÿæƒï¼Œè¿™ä¸ªç¯å°±æ˜¯è´Ÿç¯ã€‚åˆå§‹æ—¶å°†æ‰€æœ‰ç‚¹å…¥é˜Ÿï¼Œä»¥ç¡®ä¿èƒ½éå†åˆ°æ‰€æœ‰è¿é€šåˆ†é‡ã€‚

```cpp
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
const int N = 2010, M = 10010;

int n, m;
int h[N], e[M], ne[M], w[M], idx;
bool st[N];
int dist[N], cnt[N];

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

bool spfa() {
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        q.push(i);
        st[i] = true;
    }

    while (q.size()) {
        int t = q.front();
        q.pop();
        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
}

int main() {
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    if (spfa()) puts("Yes");
    else puts("No");
    return 0;
}
```
</details>

#### 5.3 Floyd-Warshall ç®—æ³•
> **æ ¸å¿ƒæ€æƒ³ (O(nÂ³))**: Floyd æ˜¯ä¸€ç§åŸºäºåŠ¨æ€è§„åˆ’çš„ç®—æ³•ï¼Œç”¨äºæ±‚è§£ **æ‰€æœ‰èŠ‚ç‚¹å¯¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼ˆAPSPï¼‰**ï¼Œå¯ä»¥å¤„ç†å¸¦è´Ÿæƒè¾¹çš„å›¾ï¼Œä½† **ä¸èƒ½å¤„ç†è´Ÿæƒç¯**ã€‚
>
> å…¶çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºï¼š`d[i][j] = min(d[i][j], d[i][k] + d[k][j])`ã€‚
> 
> è¿™è¡¨ç¤ºä» `i` åˆ° `j` çš„æœ€çŸ­è·¯å¾„ï¼Œè¦ä¹ˆæ˜¯åŸæ¥ä¸ç»è¿‡ `k` çš„è·¯å¾„ï¼Œè¦ä¹ˆæ˜¯ç»è¿‡ `k` çš„è·¯å¾„ï¼ˆ`i` -> `k` -> `j`ï¼‰ã€‚é€šè¿‡ `k` ä» 1 åˆ° n çš„ä¸‰é‡å¾ªç¯ï¼Œå³å¯æ±‚å‡ºæ‰€æœ‰ç‚¹å¯¹çš„æœ€çŸ­è·¯ã€‚

<details>
<summary><strong>Floyd (æ±‚æœ€çŸ­è·¯)</strong></summary>

![image-20240205145217224](assets/image-20240205145217224.png)

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 210, INF = 1e9;

int n, m, q;
int d[N][N];

void floyd() {
    for (int k = 1; k <= n; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
            }
        }
    }
}

int main() {
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            d[i][j] = (i == j) ? 0 : INF;
        }
    }
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        d[a][b] = min(d[a][b], c);
    }
    
    floyd();
    
    while (q--) {
        int a, b;
        cin >> a >> b;
        if (d[a][b] > INF / 2) puts("impossible");
        else cout << d[a][b] << endl;
    }
    return 0;
}
```
</details>

---

### ğŸ•¸ï¸ 6. æœ€å°ç”Ÿæˆæ ‘ (MST)

> **æ ¸å¿ƒæ€æƒ³**ï¼šæœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spanning Treeï¼‰æ˜¯é’ˆå¯¹ **æ— å‘è¿é€šå›¾** çš„ã€‚å®ƒæ˜¯åœ¨å›¾ä¸­æ‰¾å‡ºä¸€æ£µåŒ…å«æ‰€æœ‰é¡¶ç‚¹çš„æ ‘ï¼Œä¸”æ‰€æœ‰è¾¹çš„æƒå€¼ä¹‹å’Œæœ€å°ã€‚
> - **Prim ç®—æ³• (O(nÂ²))**: ç±»ä¼¼ Dijkstraï¼Œä»ä¸€ä¸ªç‚¹å¼€å§‹ï¼Œä¸æ–­å°†ç¦» **å½“å‰å·²é€‰é›†åˆ** æœ€è¿‘çš„é¡¶ç‚¹åŠ å…¥æ ‘ä¸­ã€‚
> - **Kruskal ç®—æ³• (O(m log m))**: å°†æ‰€æœ‰è¾¹æŒ‰æƒå€¼ä»å°åˆ°å¤§æ’åºï¼Œä¾æ¬¡å°è¯•åŠ å…¥è¾¹ï¼Œåªè¦ä¸å½¢æˆç¯ï¼ˆç”¨å¹¶æŸ¥é›†åˆ¤æ–­ï¼‰ï¼Œå°±åŠ å…¥ã€‚

#### 6.1 Prim ç®—æ³•
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£ (æœ´ç´ ç‰ˆ)</strong></summary>

![image-20240205160356226](assets/image-20240205160356226.png)

```cpp
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 510, INF = 0x3f3f3f3f;

int n, m;
int g[N][N];
int dist[N]; // å­˜å‚¨ç‚¹åˆ°é›†åˆçš„æœ€çŸ­è·ç¦»
bool st[N];  // æ ‡è®°æ˜¯å¦å·²åœ¨MSTä¸­

int prim() {
    memset(dist, 0x3f, sizeof dist);
    int res = 0;

    for (int i = 0; i < n; i++) {
        int t = -1;
        // æ‰¾åˆ°æœªåŠ å…¥ä¸”è·ç¦»é›†åˆæœ€è¿‘çš„ç‚¹
        for (int j = 1; j <= n; j++) {
            if (!st[j] && (t == -1 || dist[t] > dist[j])) {
                t = j;
            }
        }
        
        // å¦‚æœæ˜¯ç¨€ç–å›¾æˆ–è€…ä¸è¿é€š
        if (i > 0 && dist[t] == INF) return INF;
        
        if (i > 0) res += dist[t];
        st[t] = true;
        
        // ç”¨ t æ›´æ–°å…¶ä»–ç‚¹åˆ°é›†åˆçš„è·ç¦»
        for (int j = 1; j <= n; j++) {
            dist[j] = min(dist[j], g[t][j]);
        }
    }
    return res;
}

int main() {
    cin >> n >> m;
    memset(g, 0x3f, sizeof g);
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        g[a][b] = g[b][a] = min(g[a][b], c);
    }
    int t = prim();
    if (t == INF) puts("impossible");
    else cout << t << endl;
    return 0;
}
```
</details>

#### 6.2 Kruskal ç®—æ³•
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240206173236341](assets/image-20240206173236341.png)

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010, M = 200010;

int n, m;
int p[N];

struct Edge {
    int a, b, w;
    bool operator< (const Edge &other) const {
        return w < other.w;
    }
} edges[M];

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int a, b, w;
        cin >> a >> b >> w;
        edges[i] = {a, b, w};
    }

    sort(edges, edges + m);

    for (int i = 1; i <= n; i++) p[i] = i;

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i++) {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        int pa = find(a), pb = find(b);
        if (pa != pb) {
            p[pa] = pb;
            res += w;
            cnt++;
        }
    }

    if (cnt < n - 1) cout << "impossible" << endl;
    else cout << res << endl;
    return 0;
}```
</details>

---

### ğŸ¨ 7. äºŒåˆ†å›¾

> **æ ¸å¿ƒæ€æƒ³**ï¼šäºŒåˆ†å›¾æ˜¯æŒ‡ä¸€ä¸ªå›¾çš„é¡¶ç‚¹å¯ä»¥è¢«åˆ†ä¸ºä¸¤ä¸ªç‹¬ç«‹çš„é›†åˆ `U` å’Œ `V`ï¼Œä½¿å¾—æ‰€æœ‰è¾¹éƒ½è·¨è¶Šè¿™ä¸¤ä¸ªé›†åˆï¼Œè€Œé›†åˆå†…éƒ¨æ²¡æœ‰è¾¹ã€‚
> - **åˆ¤å®šï¼ˆæŸ“è‰²æ³•ï¼‰**: å°è¯•ç”¨ä¸¤ç§é¢œè‰²å¯¹å›¾è¿›è¡ŒæŸ“è‰²ï¼Œå¦‚æœæ‰€æœ‰ç›¸é‚»çš„é¡¶ç‚¹é¢œè‰²éƒ½ä¸åŒï¼Œåˆ™æ˜¯äºŒåˆ†å›¾ã€‚DFS æˆ– BFS å‡å¯å®ç°ã€‚
> - **æœ€å¤§åŒ¹é…ï¼ˆåŒˆç‰™åˆ©ç®—æ³•ï¼‰**: åœ¨äºŒåˆ†å›¾ä¸­å¯»æ‰¾ä¸€ä¸ªæœ€å¤§çš„è¾¹çš„é›†åˆï¼Œä½¿å¾—é›†åˆä¸­ä»»æ„ä¸¤æ¡è¾¹éƒ½æ²¡æœ‰å…¬å…±é¡¶ç‚¹ã€‚åŒˆç‰™åˆ©ç®—æ³•çš„æ ¸å¿ƒæ˜¯ä¸ºæ¯ä¸ªæœªåŒ¹é…çš„å·¦éƒ¨ç‚¹å¯»æ‰¾ **å¢å¹¿è·¯**ï¼ˆä¸€æ¡ä»æœªåŒ¹é…çš„å·¦éƒ¨ç‚¹å¼€å§‹ï¼Œä»æœªåŒ¹é…çš„å³éƒ¨ç‚¹ç»“æŸï¼Œä¸”åŒ¹é…è¾¹å’ŒéåŒ¹é…è¾¹äº¤æ›¿å‡ºç°çš„è·¯å¾„ï¼‰ã€‚

#### 7.1 æŸ“è‰²æ³•åˆ¤å®šäºŒåˆ†å›¾
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240207145306447](assets/image-20240207145306447.png)

```cpp
#include <cstring>
#include <iostream>
using namespace std;
const int N = 100010, M = 200010;

int n, m;
int h[N], e[M], ne[M], idx;
int color[N]; // 0:æœªæŸ“, 1:é¢œè‰²1, 2:é¢œè‰²2

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool dfs(int u, int c) {
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!color[j]) {
            if (!dfs(j, 3 - c)) return false;
        } else if (color[j] == c) {
            return false;
        }
    }
    return true;
}

int main() {
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while (m--) {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    bool flag = true;
    for (int i = 1; i <= n; i++) {
        if (!color[i]) {
            if (!dfs(i, 1)) {
                flag = false;
                break;
            }
        }
    }
    if (flag) puts("Yes");
    else puts("No");
    return 0;
}
```
</details>

#### 7.2 äºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£ (åŒˆç‰™åˆ©ç®—æ³•)</strong></summary>

![image-20240207164717001](assets/image-20240207164717001.png)

```cpp
#include <cstring>
#include <iostream>
using namespace std;
const int N = 510, M = 100010;

int n1, n2, m;
int h[N], e[M], ne[M], idx;
int match[N]; // match[j] = i è¡¨ç¤ºå³éƒ¨ç‚¹jä¸å·¦éƒ¨ç‚¹iåŒ¹é…
bool st[N]; // st[j] è¡¨ç¤ºæœ¬è½®æœç´¢ä¸­å³éƒ¨ç‚¹jæ˜¯å¦è¢«è®¿é—®è¿‡

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool find(int u) {
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!st[j]) {
            st[j] = true;
            if (match[j] == 0 || find(match[j])) {
                match[j] = u;
                return true;
            }
        }
    }
    return false;
}

int main() {
    cin >> n1 >> n2 >> m;
    memset(h, -1, sizeof h);
    while (m--) {
        int a, b;
        cin >> a >> b;
        add(a, b);
    }

    int res = 0;
    for (int i = 1; i <= n1; i++) {
        memset(st, false, sizeof st); // æ¯è½®ä¸ºæ–°çš„å·¦éƒ¨ç‚¹æœç´¢ï¼Œstæ•°ç»„éœ€é‡ç½®
        if (find(i)) res++;
    }
    cout << res << endl;
    return 0;
}
```
</details>
```