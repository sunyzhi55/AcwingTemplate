---
date: 2025-11-17T11:12:00
tags:
  - C++
  - Dynamic Planning
  - Algorithm
  - Time Complexity Analysis
---

# ⏱️ 时间复杂度分析

> 一页速查，帮助你根据输入规模快速选择算法与实现思路。

---



## 📌1 概述

一般来说，ACM/笔试题常见的时间限制是 `1s` 或 `2s`。在这种时间限制下，使用 C++ 时通常将允许的基本操作次数估计为约 $10^7 \sim10^8$ 次（与常数因子、内存访问、IO 等有关）。因此在设计算法时，先估算复杂度与数据规模是否匹配是非常重要的。

下面把常见的数据规模映射为允许的时间复杂度，并给出常用算法与实现建议。

## 📊2 常用复杂度对照表

| 数据规模 n | 允许时间复杂度（近似） | 常用算法 / 数据结构 | 备注 |
|---:|:---:|:---|---|
| n ≤ 30 | 指数形式 $O(2^n)$ 或更高 | DFS + 剪枝、状态压缩 DP、枚举子集 | 适用于穷举、状态压缩（2^n） |
| n ≤ 100 | $O(n^3)$ | Floyd、三重循环 DP、高斯消元 | 小规模矩阵运算或三重循环 |
| n ≤ 1e3 | $O(n^2)$ 或 $O(n^2 \log n)$ | 二分、朴素 Dijkstra/Prim、Bellman-Ford、平方级 DP | 常见的二维网格或邻接矩阵问题 |
| n ≤ 1e4 | $O(n \sqrt n)$ 或 $O(n \log n)$（视题目而定） | 分块、莫队、树分解 | 分块技巧常用于查询类问题 |
| n ≤ 1e5 | $O(n \log n)$ | 排序、线段树、树状数组、堆、并查集、Dijkstra+堆、Kruskal、后缀数组、树链剖分 | 常见题目的典型上限 |
| n ≤ 1e6 | $O(n)$ 或常数较小的 $O(n \log n)$ | 单调队列、双指针、Hash、线性筛、KMP（线性）、AC 自动机 | 注意常数与内存占用 |
| n ≤ 1e7 | $O(n)$ | 线性扫描、双指针、线性筛素数 | 在内存与缓存好的情况下可行 |
| n ≤ 1e9 | $O( \sqrt n)$ | 判断质数（试除到 sqrt(n)） | 非常接近上限，需用数学优化 |
| n ≤ 1e18 | $O( \log n)$ | 快速幂、二分、gcd、位运算 | 常见于大数指数/乘法取模 |
| 超大位数（高精度） | 与位数相关，如 $O(( \log n)^2)$ 或 $O( \log k \cdot \log \log k)$ | 高精度运算、FFT/NTT | 视位数与具体算法而定 |

##  常见算法复杂度速查

- **排序（sort）**: $O(n \log n)$
- **二分搜索**: $O( \log n)$（查找）或 $O( \log V)$（在值域上二分）
- **Dijkstra（堆实现）**: $O((E+V) \log V)$
- **Kruskal（并查集）**: $O(E \log E)$
- **线段树 / 树状数组**: $O( \log n)$ 单次操作
- **KMP / AC 自动机**: $O(n + m)$（线性）

## 🧭 如何快速估算算法是否可行（检查清单）

1. 计算复杂度：把算法复杂度表示为 $f(n)$。
2. 代入 n：把题目给的 n 代入，得到估算的基本操作次数（比如 $10^7$、$10^8$）。
3. 考虑常数：不同算法常数差别大（比如朴素常数比位运算大），选择时要考虑语言与实现细节。
4. 内存与 IO：大输入可能受 IO 限制，考虑 fast IO（`scanf/printf` 或 `ios::sync_with_stdio(false)`）。
5. 如果边界不确定，考虑多种方案：贪心/二分+验证/分块/离线处理等。

## 🧠 时间复杂度计算

- **动态规划计算量**：状态数 × 状态转移数量

### 📦 内存与数据类型常识

| 名称 | 含义 | 字节 (Byte) |
|---|:---|---:|
| `1 Byte` | 8 bit | 1 |
| `1 KB` | 1024 Byte | 1,024 |
| `1 MB` | 1024 KB | 1,048,576 |
| `1 GB` | 1024 MB | 1,073,741,824 |
| `int` | 典型 C++ 整数 | 4 |
| `char` | 字符 | 1 |
| `double`, `long long` | 双精度 / 64 位整数 | 8 |
| `__int128` | 128 位整数（GCC/Clang） | 16 |

**示例估算**：若 $f(n)=O(n \log n)$ 且 $n=10^5$，则估算约为 $10^5 \times \log_2(10^5) \approx1.7 \times10^6$ 基本操作，通常在 `1s` 范围内是安全的（取决于常数）。

## 💻 常用示例代码（C++）

### 🔢 快速幂（迭代） — 复杂度 $O( \log k)$

```cpp
long long modpow(long long a, long long k, long long mod) {
	long long res = 1 % mod;
	a %= mod;
	while (k > 0) {
		if (k & 1) res = (__int128)res * a % mod;
		a = (__int128)a * a % mod;
		k >>= 1;
	}
	return res;
}
```

### 🧮 欧几里得（gcd） — 复杂度约 $O( \log  \min(a,b))$

```cpp
long long gcd(long long a, long long b) {
	while (b) {
		long long t = a % b;
		a = b; b = t;
	}
	return a;
}
```

### 🧾 线性筛（Euler 筛） — 复杂度 $O(n)$

```cpp
vector<int> primes;
vector<int> lp(n+1, 0);
for (int i = 2; i <= n; ++i) {
	if (lp[i] == 0) { lp[i] = i; primes.push_back(i); }
	for (int p : primes) {
		if (p > lp[i] || 1LL * p * i > n) break;
		lp[p * i] = p;
	}
}
```

KMP（匹配）复杂度 $O(n+m)$：构造 next 数组与匹配均为线性时间。

## 🛠️ 实用小技巧

- 对于不确定是否超时，先写 $O(n \log n)$ 的解法并在本地用最大数据规模做粗略基准测试。
- 注意常数因素：位运算、数组访问比 STL 容器（如 `map`）更快；`unordered_map` 常数较小但有哈希冲突开销。
- IO 对时间影响较大，尽量使用快速 IO：

```cpp
ios::sync_with_stdio(false);
cin.tie(nullptr);
```

## ✅ 总结

按数据规模选择复杂度是解题的第一步：用上表快速匹配算法类别，结合常数与内存估计判断是否需要进一步优化（如分治、分块、离线、剪枝或数学优化）。

