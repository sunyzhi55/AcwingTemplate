---
date: 2025-10-21T22:01:00
tags:
  - C++
  - Algorithm
  - Math
  - Number Theory
---

# ğŸ“ AcWingâ€”â€”ç®—æ³•åŸºç¡€è¯¾

![Language](https://img.shields.io/badge/Language-C%2B%2B-00599C?style=flat-square&logo=c%2B%2B)
![Topic](https://img.shields.io/badge/Topic-Math%20%26%20Number%20Theory-purple?style=flat-square)
![License](https://img.shields.io/badge/License-MIT-lightgrey?style=flat-square)
![Updated](https://img.shields.io/badge/Updated-2025--10--22-lightgrey?style=flat-square)

> ç¬¬å››è®² Â· æ•°å­¦çŸ¥è¯† Â· è´¨æ•° / çº¦æ•° / æ¬§æ‹‰å‡½æ•° / å¿«é€Ÿå¹‚ / ç»„åˆæ•° / åšå¼ˆè®º

---

## ğŸ”¢ ç¬¬å››è®² æ•°å­¦çŸ¥è¯†

### ğŸ¯ 1. è´¨æ•° (Prime Numbers)

> **æ ¸å¿ƒæ€æƒ³**ï¼šè´¨æ•°ï¼ˆç´ æ•°ï¼‰æ˜¯æŒ‡åœ¨å¤§äº1çš„è‡ªç„¶æ•°ä¸­ï¼Œé™¤äº†1å’Œå®ƒæœ¬èº«ä»¥å¤–ä¸å†æœ‰å…¶ä»–å› æ•°çš„è‡ªç„¶æ•°ã€‚è´¨æ•°æ˜¯æ•°è®ºçš„åŸºçŸ³ã€‚

#### 1.1 è¯•é™¤æ³•åˆ¤å®šè´¨æ•°
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240208154627833](assets/image-20240208154627833.png)

> **è§£æ³•æ€è·¯**ï¼šä¸€ä¸ªæ•° `n` å¦‚æœæ˜¯åˆæ•°ï¼Œé‚£ä¹ˆå®ƒå¿…ç„¶å­˜åœ¨ä¸€ä¸ªå°äºç­‰äº `sqrt(n)` çš„å› å­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åªéœ€æ£€æŸ¥ä» 2 åˆ° `sqrt(n)`ï¼ˆå³ `i <= n/i`ï¼‰æ˜¯å¦å­˜åœ¨èƒ½æ•´é™¤ `n` çš„æ•° `i` å³å¯ã€‚

```cpp
#include <iostream>
using namespace std;

bool is_prime(int x) {
    if (x < 2) return false;
    // x çš„ä¸€ä¸ªæ›´å°çš„å› å­ä¸º i ï¼Œå¦ä¸€ä¸ªæ›´å¤§çš„å› å­ä¸º x / i
    // åªéœ€éå†åˆ° sqrt(x) å³å¯
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) return false;
    }
    return true;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        int x;
        cin >> x;
        if (is_prime(x)) puts("Yes");
        else puts("No");
    }
    return 0;
}
```
</details>

#### 1.2 åˆ†è§£è´¨å› æ•°
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240208162404221](assets/image-20240208162404221.png)

> **è§£æ³•æ€è·¯**ï¼šåŒæ ·åˆ©ç”¨ `i <= n/i` çš„æ€§è´¨ã€‚ä»å°åˆ°å¤§éå† `i`ï¼Œå¦‚æœ `i` æ˜¯ `n` çš„å› å­ï¼Œåˆ™ `i` å¿…ä¸ºè´¨æ•°ï¼ˆå› ä¸º `n` çš„æ›´å°è´¨å› å­å·²è¢«é™¤å°½ï¼‰ã€‚æˆ‘ä»¬ç»Ÿè®¡ `i` çš„ä¸ªæ•°ï¼Œç„¶åå°† `n` ä¸­æ‰€æœ‰çš„ `i` éƒ½é™¤æ‰ã€‚å¾ªç¯ç»“æŸåï¼Œå¦‚æœ `n > 1`ï¼Œè¯´æ˜å‰©ä¸‹çš„ `n` æœ¬èº«å°±æ˜¯é‚£ä¸ªå¤§äº `sqrt(åŸn)` çš„è´¨å› å­ã€‚

```cpp
#include <iostream>
using namespace std;

void divide(int x) {
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) {
            int s = 0;
            while (x % i == 0) {
                x /= i;
                s++;
            }
            cout << i << ' ' << s << endl;
        }
    }
    // å¤„ç†æœ€åä¸€ä¸ªå¤§äº sqrt(åŸx) çš„è´¨å› å­
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        int x;
        cin >> x;
        divide(x);
    }
    return 0;
}
```
</details>

#### 1.3 ç­›æ³•æ±‚è´¨æ•°
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240208165154655](assets/image-20240208165154655.png)

> **åŸƒæ°ç­›æ³• (O(n log log n))**ï¼šä» 2 å¼€å§‹ï¼Œå°†æ¯ä¸ªè´¨æ•°çš„å€æ•°éƒ½æ ‡è®°ä¸ºåˆæ•°ã€‚
> **çº¿æ€§ç­›æ³• (O(n))**ï¼šæ ¸å¿ƒæ˜¯ **æ¯ä¸ªåˆæ•°åªè¢«å…¶æœ€å°çš„è´¨å› å­ç­›æ‰ä¸€æ¬¡**ã€‚éå† 2 åˆ° nï¼Œå¦‚æœ `i` æ˜¯è´¨æ•°åˆ™åŠ å…¥ç´ æ•°è¡¨ã€‚ç„¶åç”¨å·²ç­›å‡ºçš„ç´ æ•° `p` å»ç­› `i*p`ã€‚å…³é”®ä¸€æ­¥æ˜¯ `if (i % p == 0) break;`ï¼Œè¿™ä¿è¯äº† `p` æ˜¯ `i` çš„æœ€å°è´¨å› å­ï¼Œä»è€Œä¹Ÿæ˜¯ `i*p` çš„æœ€å°è´¨å› å­ã€‚

> **åŸƒæ°ç­›æ³•æ¨¡æ¿**
```cpp
int primes[N], cnt;
bool st[N];

void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;
            for (int j = i + i; j <= n; j += i) {
                st[j] = true;
            }
        }
    }
}
```

> **çº¿æ€§ç­›æ³•é¢˜è§£**
```cpp
#include <iostream>
using namespace std;
const int N = 1000010;

int primes[N], cnt;
bool st[N]; // st[x]=true è¡¨ç¤º x æ˜¯åˆæ•°

void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cnt++] = i;
        // ç”¨å·²ç­›å‡ºçš„ç´ æ•°å»ç­›æ‰åˆæ•°
        for (int j = 0; primes[j] <= n / i; j++) {
            st[primes[j] * i] = true;
            // å…³é”®ï¼šprimes[j] æ˜¯ i çš„æœ€å°è´¨å› å­ï¼Œä¹Ÿæ˜¯ primes[j]*i çš„æœ€å°è´¨å› å­
            // åé¢çš„ç´ æ•°å†ä¹˜iï¼Œå…¶æœ€å°è´¨å› å­å°±ä¸æ˜¯é‚£ä¸ªç´ æ•°äº†ï¼Œè€Œæ˜¯primes[j]
            if (i % primes[j] == 0) break;
        }
    }
}

int main() {
    int n;
    cin >> n;
    get_primes(n);
    cout << cnt << endl;
    return 0;
}
```
</details>

---

### â— 2. çº¦æ•° (Divisors)

#### 2.1 è¯•é™¤æ³•æ±‚çº¦æ•°
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240217104638829](assets/image-20240217104638829.png)

> **è§£æ³•æ€è·¯**ï¼šçº¦æ•°æ€»æ˜¯æˆå¯¹å‡ºç°çš„ã€‚å¦‚æœ `i` æ˜¯ `x` çš„çº¦æ•°ï¼Œé‚£ä¹ˆ `x/i` ä¹Ÿæ˜¯ã€‚æˆ‘ä»¬åªéœ€éå†ä» 1 åˆ° `sqrt(x)`ï¼Œæ‰¾åˆ°æ‰€æœ‰å°çº¦æ•° `i`ï¼ŒåŒæ—¶ä¹Ÿå°±æ‰¾åˆ°äº†å¤§çº¦æ•° `x/i`ã€‚æ³¨æ„ `i == x/i` çš„æƒ…å†µï¼Œé¿å…é‡å¤æ·»åŠ ã€‚

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> get_divisors(int x) {
    vector<int> res;
    for (int i = 1; i <= x / i; i++) {
        if (x % i == 0) {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    }
    sort(res.begin(), res.end());
    return res;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        int x;
        cin >> x;
        auto res = get_divisors(x);
        for (int d : res) cout << d << ' ';
        cout << endl;
    }
    return 0;
}
```
</details>

#### 2.2 çº¦æ•°ä¸ªæ•°
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>
![image-20240217153842909](assets/image-20240217153842909.png)

> **çº¦æ•°ä¸ªæ•°å®šç†**ï¼šå¦‚æœä¸€ä¸ªæ•° `N` çš„æ ‡å‡†è´¨å› å­åˆ†è§£ä¸º `N = p1^a1 * p2^a2 * ... * pk^ak`ï¼Œé‚£ä¹ˆ `N` çš„çº¦æ•°ä¸ªæ•°ä¸º `(a1 + 1) * (a2 + 1) * ... * (ak + 1)`ã€‚
>
> **è§£æ³•æ€è·¯**ï¼šå…ˆå¯¹æ¯ä¸ªè¾“å…¥çš„æ•°åˆ†è§£è´¨å› æ•°ï¼Œç”¨ `unordered_map` ç´¯åŠ æ‰€æœ‰è´¨å› å­çš„æŒ‡æ•°ã€‚æœ€åæ ¹æ®å®šç†ï¼Œå°†æ¯ä¸ªæŒ‡æ•°åŠ  1 åè¿ä¹˜èµ·æ¥ã€‚

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;
typedef long long LL;
const int mod = 1e9 + 7;

int main() {
    int n;
    cin >> n;
    unordered_map<int, int> primes;
    while (n--) {
        int x;
        cin >> x;
        for (int i = 2; i <= x / i; i++) {
            while (x % i == 0) {
                x /= i;
                primes[i]++;
            }
        }
        if (x > 1) primes[x]++;
    }

    LL res = 1;
    for (auto p : primes) {
        res = res * (p.second + 1) % mod;
    }
    cout << res << endl;
    return 0;
}```
</details>

#### 2.3 çº¦æ•°ä¹‹å’Œ
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>
![image-20240217162152651](assets/image-20240217162152651.png)

> **çº¦æ•°å’Œå®šç†**ï¼šå¦‚æœ `N = p1^a1 * p2^a2 * ... * pk^ak`ï¼Œé‚£ä¹ˆ `N` çš„æ‰€æœ‰æ­£çº¦æ•°ä¹‹å’Œä¸º `(p1^0 + ... + p1^a1) * ... * (pk^0 + ... + pk^ak)`ã€‚
>
> **è§£æ³•æ€è·¯**ï¼šåŒä¸Šï¼Œå…ˆç´¯åŠ æ‰€æœ‰è´¨å› å­çš„æŒ‡æ•°ã€‚ç„¶åå¯¹æ¯ä¸ªè´¨å› å­ `p` å’Œå…¶æŒ‡æ•° `a`ï¼Œè®¡ç®— `(p^0 + ... + p^a)` çš„å€¼ï¼Œå†å°†è¿™äº›å’Œè¿ä¹˜èµ·æ¥ã€‚

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;
typedef long long LL;
const int mod = 1e9 + 7;

int main() {
    int n;
    cin >> n;
    unordered_map<int, int> primes;
    while (n--) {
        int x;
        cin >> x;
        for (int i = 2; i <= x / i; i++) {
            while (x % i == 0) {
                x /= i;
                primes[i]++;
            }
        }
        if (x > 1) primes[x]++;
    }

    LL res = 1;
    for (auto p : primes) {
        LL prime = p.first, alpha = p.second;
        LL t = 1;
        // è®¡ç®— (p^0 + ... + p^a)
        while (alpha--) t = (t * prime + 1) % mod;
        res = res * t % mod;
    }
    cout << res << endl;
    return 0;
}
```
</details>

#### 2.4 æœ€å¤§å…¬çº¦æ•° (GCD)
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240217165505252](assets/image-20240217165505252.png)

> **æ¬§å‡ é‡Œå¾—ç®—æ³• (è¾—è½¬ç›¸é™¤æ³•)**ï¼š`gcd(a, b) = gcd(b, a % b)`ï¼Œé€’å½’è¾¹ç•Œæ˜¯å½“ `b` ä¸º 0 æ—¶ï¼Œ`gcd` ä¸º `a`ã€‚è¿™æ˜¯æ±‚æœ€å¤§å…¬çº¦æ•°æœ€é«˜æ•ˆçš„æ–¹æ³•ã€‚

```cpp
#include <iostream>
using namespace std;

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        int a, b;
        cin >> a >> b;
        cout << gcd(a, b) << endl;
    }
    return 0;
}
```
</details>

---

### ğŸ‡ªğŸ‡º 3. æ¬§æ‹‰å‡½æ•°

> **æ ¸å¿ƒæ€æƒ³**ï¼šæ¬§æ‹‰å‡½æ•° `Ï†(n)` (phi function) è¡¨ç¤ºåœ¨ 1 åˆ° n ä¸­ä¸ n **äº’è´¨** çš„æ­£æ•´æ•°çš„ä¸ªæ•°ã€‚
>
> **è®¡ç®—å…¬å¼**ï¼šå¦‚æœ `n = p1^a1 * ... * pk^ak`ï¼Œåˆ™ `Ï†(n) = n * (1 - 1/p1) * ... * (1 - 1/pk)`ã€‚

#### 3.1 æ±‚å•ä¸ªæ¬§æ‹‰å‡½æ•°
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240217171909347](assets/image-20240217171909347.png)

> **è§£æ³•æ€è·¯**ï¼šç›´æ¥åº”ç”¨å…¬å¼ã€‚å…ˆå¯¹ `n` åˆ†è§£è´¨å› æ•°ï¼Œæ‰¾åˆ°æ‰€æœ‰è´¨å› å­ `p`ï¼Œç„¶åç”¨ `res = res / p * (p-1)` æ¥è®¡ç®—ï¼Œä»¥é¿å…æµ®ç‚¹æ•°è¿ç®—ã€‚

```cpp
#include <iostream>
using namespace std;

int phi(int x) {
    int res = x;
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    }
    if (x > 1) res = res / x * (x - 1);
    return res;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        int x;
        cin >> x;
        cout << phi(x) << endl;
    }
    return 0;
}
```
</details>

#### 3.2 ç­›æ³•æ±‚æ¬§æ‹‰å‡½æ•°
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>

![image-20240219110124715](assets/image-20240219110124715.png)

> **è§£æ³•æ€è·¯**ï¼šåœ¨çº¿æ€§ç­›è´¨æ•°çš„åŸºç¡€ä¸Šï¼Œåˆ©ç”¨æ¬§æ‹‰å‡½æ•°çš„æ€§è´¨æ¥é€’æ¨è®¡ç®— `Ï†` å€¼ã€‚
> -   å¦‚æœ `i` æ˜¯è´¨æ•°, `Ï†(i) = i - 1`ã€‚
> -   å¦‚æœ `i % p == 0`ï¼Œ`p` æ˜¯ `i` çš„æœ€å°è´¨å› å­ï¼Œåˆ™ `i` å’Œ `i*p` å«æœ‰ç›¸åŒçš„è´¨å› å­ï¼Œ`Ï†(i*p) = Ï†(i) * p`ã€‚
> -   å¦‚æœ `i % p != 0`ï¼Œ`p` ä¸æ˜¯ `i` çš„è´¨å› å­ï¼Œåˆ™ `p` ä¸ `i` äº’è´¨ï¼Œ`Ï†(i*p) = Ï†(i) * Ï†(p) = Ï†(i) * (p - 1)`ã€‚

```cpp
#include <iostream>
using namespace std;
typedef long long LL;
const int N = 1000010;

int primes[N], euler[N], cnt;
bool st[N];

void get_eulers(int n) {
    euler = 1;
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j++) {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0) {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}

int main() {
    int n;
    cin >> n;
    get_eulers(n);
    LL res = 0;
    for (int i = 1; i <= n; i++) res += euler[i];
    cout << res << endl;
    return 0;
}```
</details>

---

### ğŸš€ 4. å¿«é€Ÿå¹‚

> **æ ¸å¿ƒæ€æƒ³**ï¼šå¿«é€Ÿå¹‚ç®—æ³•ç”¨äºé«˜æ•ˆè®¡ç®— `a^b mod p`ã€‚å®ƒå°†æŒ‡æ•° `b` è¿›è¡ŒäºŒè¿›åˆ¶æ‹†åˆ†ï¼Œä¾‹å¦‚ `a^13 = a^(8+4+1) = a^8 * a^4 * a^1`ã€‚é€šè¿‡å¾ªç¯ï¼Œæ¯æ¬¡å°†åº•æ•°å¹³æ–¹ï¼Œå¹¶æ ¹æ® `b` çš„äºŒè¿›åˆ¶ä½å†³å®šæ˜¯å¦å°†å½“å‰åº•æ•°ä¹˜å…¥ç»“æœã€‚æ—¶é—´å¤æ‚åº¦ä» O(b) é™è‡³ O(log b)ã€‚

#### 4.1 å¿«é€Ÿå¹‚
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>
![image-20240219171741661](assets/image-20240219171741661.png)

```cpp
#include <iostream>
using namespace std;
typedef long long LL;

LL qmi(int a, int b, int p) {
    LL res = 1 % p;
    LL base = a;
    while (b) {
        if (b & 1) res = res * base % p;
        base = base * base % p;
        b >>= 1;
    }
    return res;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        int a, b, p;
        cin >> a >> b >> p;
        cout << qmi(a, b, p) << endl;
    }
    return 0;
}
```
</details>

#### 4.2 å¿«é€Ÿå¹‚æ±‚é€†å…ƒ
<details>
<summary><strong>ğŸ¯ AcWing é¢˜ç›®ä¸é¢˜è§£</strong></summary>
![image-20240219174812186](assets/image-20240219174812186.png)

> **è´¹é©¬å°å®šç†**ï¼šå¦‚æœ `p` æ˜¯ä¸€ä¸ªè´¨æ•°ï¼Œä¸” `a` ä¸æ˜¯ `p` çš„å€æ•°ï¼ˆå³ `a` å’Œ `p` äº’è´¨ï¼‰ï¼Œé‚£ä¹ˆ `a^(p-1) â‰¡ 1 (mod p)`ã€‚
>
> **æ±‚é€†å…ƒ**ï¼šç”± `a * a^(p-2) â‰¡ 1 (mod p)` å¯çŸ¥ï¼Œ`a` åœ¨æ¨¡ `p` æ„ä¹‰ä¸‹çš„ä¹˜æ³•é€†å…ƒå°±æ˜¯ `a^(p-2) mod p`ã€‚æˆ‘ä»¬å¯ä»¥ç”¨å¿«é€Ÿå¹‚æ¥è®¡ç®—è¿™ä¸ªå€¼ã€‚

```cpp
#include <iostream>
using namespace std;
typedef long long LL;

LL qmi(int a, int b, int p) {
    LL res = 1 % p;
    LL base = a;
    while (b) {
        if (b & 1) res = res * base % p;
        base = base * base % p;
        b >>= 1;
    }
    return res;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        int a, p;
        cin >> a >> p;
        if (a % p == 0) puts("impossible");
        else cout << qmi(a, p - 2, p) << endl;
    }
    return 0;
}
```
</details>

---
### â• 5. æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•

> **æ ¸å¿ƒæ€æƒ³**ï¼šæ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ç”¨äºæ±‚è§£å½¢å¦‚ `ax + by = gcd(a, b)` çš„æ–¹ç¨‹çš„ä¸€ç»„æ•´æ•°è§£ `(x, y)`ã€‚å®ƒåœ¨æ¬§å‡ é‡Œå¾—ç®—æ³•é€’å½’æ±‚ `gcd` çš„åŸºç¡€ä¸Šï¼Œåå‘æ¨å¯¼å‡ºè§£ã€‚
>
> **é€’æ¨å…³ç³»**ï¼šå½“ `b=0` æ—¶ï¼Œ`ax + 0*y = a`ï¼Œè§£ä¸º `x=1, y=0`ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬é€’å½’æ±‚è§£ `bx' + (a%b)y' = gcd(b, a%b)`ï¼Œç„¶åæ ¹æ® `x = y'` å’Œ `y = x' - (a/b)y'` æ¨å¯¼å‡ºåŸæ–¹ç¨‹çš„è§£ã€‚

<details>
<summary><strong>æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ¨¡æ¿ä¸é¢˜è§£</strong></summary>
![image-20240220095303626](assets/image-20240220095303626.png)

```cpp
#include <iostream>
using namespace std;

// æ±‚è§£ ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        int a, b, x, y;
        cin >> a >> b;
        exgcd(a, b, x, y);
        cout << x << " " << y << endl;
    }
    return 0;
}
```
</details>

<details>
<summary><strong>çº¿æ€§åŒä½™æ–¹ç¨‹</strong></summary>
![image-20240220162334884](assets/image-20240220162334884.png)

> **è§£æ³•æ€è·¯**ï¼šæ–¹ç¨‹ `ax â‰¡ b (mod m)` ç­‰ä»·äº `ax - b = my`ï¼ˆ`y`ä¸ºæŸä¸ªæ•´æ•°ï¼‰ï¼Œå³ `ax - my = b`ã€‚è¿™å’Œ `ax + by = c` å½¢å¼ç›¸åŒã€‚
> 1.  ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚ `ax' + my' = gcd(a, m)` çš„è§£ `(x', y')`ã€‚
> 2.  æ–¹ç¨‹æœ‰è§£çš„å……è¦æ¡ä»¶æ˜¯ `gcd(a, m)` èƒ½æ•´é™¤ `b`ã€‚
> 3.  è‹¥æœ‰è§£ï¼Œåˆ™åŸæ–¹ç¨‹çš„ä¸€ä¸ªè§£ `x = x' * (b / gcd(a, m))`ã€‚
> 4.  é€šè§£ä¸º `x + k * (m / gcd(a, m))`ï¼Œæœ€å°æ­£æ•´æ•°è§£ä¸º `(x % (m/d) + (m/d)) % (m/d)`ã€‚

```cpp
#include <iostream>
using namespace std;
typedef long long LL;

int exgcd(int a, int b, int &x, int &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        int a, b, m;
        cin >> a >> b >> m;
        int x, y;
        int d = exgcd(a, m, x, y);
        if (b % d != 0) puts("impossible");
        else {
            // x' = x * (b/d), m' = m/d. æœ€å°æ­£æ•´æ•°è§£
            LL res = (LL)x * (b / d);
            cout << (res % (m / d) + (m / d)) % (m / d) << endl;
        }
    }
    return 0;
}
```
</details>

---

### ğŸ”¢ 8. æ±‚ç»„åˆæ•°

> **æ ¸å¿ƒæ€æƒ³**ï¼šç»„åˆæ•° `C(a, b)` è¡¨ç¤ºä» `a` ä¸ªä¸åŒå…ƒç´ ä¸­å–å‡º `b` ä¸ªå…ƒç´ çš„æ–¹æ¡ˆæ•°ã€‚
>
> **æ–¹æ³•**ï¼š
> 1.  **é€’æ¨æ³• (O(nÂ²))**: `C(a, b) = C(a-1, b) + C(a-1, b-1)`ã€‚é€‚ç”¨äº `a, b` èŒƒå›´è¾ƒå°ã€‚
> 2.  **é¢„å¤„ç†é˜¶ä¹˜+é€†å…ƒ (O(n log mod))**: `C(a, b) = a! / (b! * (a-b)!)`ã€‚ç”¨å¿«é€Ÿå¹‚æ±‚é€†å…ƒã€‚é€‚ç”¨äº `a, b` è¾ƒå¤§ï¼Œæ¨¡æ•°ä¸ºè´¨æ•°ã€‚
> 3.  **å¢å¡æ–¯å®šç† (O(p log_p n))**: `C(a, b) â‰¡ C(a/p, b/p) * C(a%p, b%p) (mod p)`ã€‚é€‚ç”¨äº `a, b` å¾ˆå¤§ï¼Œä½†æ¨¡æ•° `p` è¾ƒå°çš„è´¨æ•°ã€‚
> 4.  **é«˜ç²¾åº¦+è´¨å› æ•°åˆ†è§£**: å½“éœ€è¦æ±‚çœŸå®å€¼ä¸”ç»“æœå¾ˆå¤§æ—¶ï¼Œå¯¹ `a!, b!, (a-b)!` åˆ†è§£è´¨å› æ•°ï¼Œçº¦åˆ†åå†ç”¨é«˜ç²¾åº¦ä¹˜æ³•è®¡ç®—ã€‚

<details>
<summary><strong>æ±‚ç»„åˆæ•° I (é€’æ¨æ³•)</strong></summary>
![image-20240221092834023](assets/image-20240221092834023.png)

```cpp
#include <iostream>
using namespace std;
const int N = 2010, mod = 1e9 + 7;
int c[N][N];

void init() {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j <= i; j++) {
            if (!j) c[i][j] = 1;
            else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
        }
    }
}

int main() {
    init();
    int n;
    cin >> n;
    while (n--) {
        int a, b;
        cin >> a >> b;
        cout << c[a][b] << endl;
    }
    return 0;
}
```
</details>

<details>
<summary><strong>æ±‚ç»„åˆæ•° II (é˜¶ä¹˜é€†å…ƒ)</strong></summary>
![image-20240221095734729](assets/image-20240221095734729.png)

```cpp
#include <iostream>
using namespace std;
typedef long long LL;
const int N = 100010, mod = 1e9 + 7;
int fact[N], infact[N];

int qmi(int a, int k, int p) { /* å¿«é€Ÿå¹‚æ¨¡æ¿ */ }

void init() {
    fact = infact = 1;
    for (int i = 1; i < N; i++) {
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    }
}

int main() {
    init();
    int n;
    cin >> n;
    while (n--) {
        int a, b;
        cin >> a >> b;
        cout << (LL)fact[a] * infact[b] % mod * infact[a - b] % mod << endl;
    }
    return 0;
}
```
</details>

<details>
<summary><strong>æ±‚ç»„åˆæ•° III (å¢å¡æ–¯å®šç†)</strong></summary>
![image-20240221104052669](assets/image-20240221104052669.png)

```cpp
#include <iostream>
using namespace std;
typedef long long LL;

int qmi(int a, int k, int p) { /* å¿«é€Ÿå¹‚æ¨¡æ¿ */ }

int C(int a, int b, int p) {
    if (b > a) return 0;
    int res = 1;
    for (int i = 1, j = a; i <= b; i++, j--) {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2, p) % p;
    }
    return res;
}

int lucas(LL a, LL b, int p) {
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        LL a, b;
        int p;
        cin >> a >> b >> p;
        cout << lucas(a, b, p) << endl;
    }
    return 0;
}
```
</details>

<details>
<summary><strong>æ±‚ç»„åˆæ•° IV (é«˜ç²¾åº¦)</strong></summary>
![image-20240221170231204](assets/image-20240221170231204.png)

```cpp
// æ ¸å¿ƒé€»è¾‘
// 1. çº¿æ€§ç­›é¢„å¤„ç† 1~a çš„æ‰€æœ‰è´¨æ•°
get_primes(a);
// 2. è®¡ç®—æ¯ä¸ªè´¨å› å­ p åœ¨ C(a,b) ä¸­çš„æ¬¡æ•°
// æ¬¡æ•° = get(a, p) - get(b, p) - get(a-b, p)
// å…¶ä¸­ get(n, p) è®¡ç®— n! ä¸­è´¨å› å­ p çš„ä¸ªæ•°
for (int i = 0; i < cnt; i++) {
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}
// 3. ç”¨é«˜ç²¾åº¦ä¹˜æ³•å°†æ‰€æœ‰è´¨å› å­ p^sum[i] ä¹˜èµ·æ¥
vector<int> res;
res.push_back(1);
for (int i = 0; i < cnt; i++) {
    for (int j = 0; j < sum[i]; j++) {
        res = mul(res, primes[i]);
    }
}
```
</details>

<details>
<summary><strong>æ»¡è¶³æ¡ä»¶çš„01åºåˆ— (å¡ç‰¹å…°æ•°)</strong></summary>
![image-20240222100819729](assets/image-20240222100819729.png)

> **æ ¸å¿ƒç»“è®º (å¡ç‰¹å…°æ•°)**ï¼š`n` ä¸ª 0 å’Œ `n` ä¸ª 1 ç»„æˆçš„ã€ä»»æ„å‰ç¼€ä¸­ 0 çš„ä¸ªæ•°ä¸å°‘äº 1 çš„ä¸ªæ•°çš„åºåˆ—æ•°é‡ä¸ºå¡ç‰¹å…°æ•° `Cat(n) = C(2n, n) / (n + 1)`ã€‚

```cpp
#include <iostream>
using namespace std;
typedef long long LL;
const int mod = 1e9 + 7;

LL qmi(LL a, int k, int p) { /* å¿«é€Ÿå¹‚ */ }

LL C(int a, int b, int p) {
    if (b > a) return 0;
    LL res = 1;
    for (int i = 1, j = a; i <= b; i++, j--) {
        res = res * j % p;
        res = res * qmi(i, p - 2, p) % p;
    }
    return res;
}

int main() {
    int n;
    cin >> n;
    LL res = C(2 * n, n, mod);
    LL inv_n1 = qmi(n + 1, mod - 2, mod);
    cout << res * inv_n1 % mod << endl;
    return 0;
}
```
</details>

---

### ğŸ­ 9. å®¹æ–¥åŸç†

> **æ ¸å¿ƒæ€æƒ³**ï¼šåœ¨è®¡æ•°æ—¶ï¼Œè¦ä¿è¯æ¯ä¸ªå…ƒç´ åªè¢«è®¡ç®—ä¸€æ¬¡ã€‚å®¹æ–¥åŸç†æä¾›äº†ä¸€ä¸ªå…¬å¼æ¥è®¡ç®—å¤šä¸ªé›†åˆå¹¶é›†çš„å¤§å°ï¼š`|AâˆªB| = |A| + |B| - |Aâˆ©B|`ã€‚å¯¹äºå¤šä¸ªé›†åˆï¼Œå…¬å¼ä¸ºï¼šå¥‡æ•°ä¸ªé›†åˆäº¤é›†ä¹‹å’Œï¼Œå‡å»å¶æ•°ä¸ªé›†åˆäº¤é›†ä¹‹å’Œã€‚

<details>
<summary><strong>èƒ½è¢«æ•´é™¤çš„æ•°</strong></summary>

![image-20240222111632771](assets/image-20240222111632771.png)

> **è§£æ³•æ€è·¯**ï¼šæ±‚ 1~n ä¸­èƒ½è¢« `p1, p2, ..., pm` ä¸­è‡³å°‘ä¸€ä¸ªæ•°æ•´é™¤çš„æ•°çš„ä¸ªæ•°ã€‚
> -   èƒ½è¢« `pi` æ•´é™¤çš„æ•°æœ‰ `floor(n/pi)` ä¸ªã€‚
> -   æ ¹æ®å®¹æ–¥åŸç†ï¼Œç­”æ¡ˆ = `Î£(n/pi) - Î£(n/lcm(pi,pj)) + ...`
> -   ç”±äº `pi` éƒ½æ˜¯è´¨æ•°ï¼Œ`lcm(pi, pj) = pi * pj`ã€‚
> -   æˆ‘ä»¬ç”¨äºŒè¿›åˆ¶æšä¸¾ `1` åˆ° `2^m - 1` çš„æ‰€æœ‰å­é›†ã€‚æ¯ä¸ªå­é›†ä»£è¡¨ä¸€ä¸ªäº¤é›†ã€‚å¦‚æœå­é›†å¤§å°ä¸ºå¥‡æ•°ï¼Œåˆ™åŠ ä¸Š `n / (å­é›†ä¸­æ‰€æœ‰piçš„ä¹˜ç§¯)`ï¼›å¦‚æœä¸ºå¶æ•°ï¼Œåˆ™å‡å»ã€‚

```cpp
#include <iostream>
using namespace std;
typedef long long LL;
const int N = 20;
int p[N];

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i++) cin >> p[i];

    int res = 0;
    // éå†æ‰€æœ‰éç©ºå­é›†
    for (int i = 1; i < 1 << m; i++) {
        LL t = 1;
        int s = 0; // å­é›†å¤§å°
        for (int j = 0; j < m; j++) {
            if (i >> j & 1) {
                if (t * p[j] > n) {
                    t = -1;
                    break;
                }
                t *= p[j];
                s++;
            }
        }
        if (t != -1) {
            if (s % 2) res += n / t; // å¥‡åŠ 
            else res -= n / t;       // å¶å‡
        }
    }
    cout << res << endl;
    return 0;
}
```
</details>

---

### ğŸ² 10. åšå¼ˆè®º

> **æ ¸å¿ƒæ€æƒ³**ï¼šåšå¼ˆè®ºç ”ç©¶å†³ç­–è€…çš„è¡Œä¸ºå’Œæœ€ä¼˜ç­–ç•¥ã€‚åœ¨ç®—æ³•ç«èµ›ä¸­ï¼Œä¸»è¦æ¶‰åŠå…¬å¹³ç»„åˆæ¸¸æˆï¼ˆICGï¼‰ã€‚
> -   **å¿…èƒœæ€ (N-state)**: å­˜åœ¨ä¸€ç§èµ°æ³•ï¼Œèƒ½åˆ°è¾¾ä¸€ä¸ªå¿…è´¥æ€ã€‚
> -   **å¿…è´¥æ€ (P-state)**: æ— è®ºæ€ä¹ˆèµ°ï¼Œéƒ½åªèƒ½åˆ°è¾¾å¿…èƒœæ€ã€‚
> -   **SG å‡½æ•°**: `SG(x) = mex({SG(y1), SG(y2), ...})`ï¼Œå…¶ä¸­ `y` æ˜¯ `x` çš„åç»§çŠ¶æ€ã€‚`SG(x) > 0` ä¸ºå¿…èƒœæ€ï¼Œ`SG(x) = 0` ä¸ºå¿…è´¥æ€ã€‚
> -   **Nim æ¸¸æˆ**: `n` å †çŸ³å­ï¼Œæ¯æ¬¡ä»ä¸€å †ä¸­å–ä»»æ„ä¸ªã€‚æ‰€æœ‰çŸ³å­æ•°å¼‚æˆ–å’Œä¸ä¸º 0 åˆ™å…ˆæ‰‹å¿…èƒœï¼Œå¦åˆ™å¿…è´¥ã€‚

<details>
<summary><strong>Nim æ¸¸æˆ</strong></summary>
![image-20240222175803606](assets/image-20240222175803606.png)

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int res = 0;
    while (n--) {
        int x;
        cin >> x;
        res ^= x;
    }
    if (res) puts("Yes"); // å¼‚æˆ–å’Œä¸ä¸º0ï¼Œå…ˆæ‰‹å¿…èƒœ
    else puts("No");
    return 0;
}
```
</details>

<details>
<summary><strong>å°é˜¶-Nim æ¸¸æˆ</strong></summary>
![image-20240222180647209](assets/image-20240222180647209.png)

> **æ ¸å¿ƒç»“è®º**ï¼šåªæœ‰ **å¥‡æ•°å·å°é˜¶** ä¸Šçš„çŸ³å­ä¼šå½±å“åšå¼ˆç»“æœã€‚è¿™ç›¸å½“äºå¯¹æ‰€æœ‰å¥‡æ•°å·å°é˜¶çš„çŸ³å­å †åšä¸€ä¸ª Nim æ¸¸æˆã€‚å¶æ•°å°é˜¶ä¸Šçš„çŸ³å­å¯ä»¥è¢«å¯¹æ‰‹é€šè¿‡ç§»åˆ°å¥‡æ•°å°é˜¶æ¥â€œæ¨¡ä»¿â€æ“ä½œï¼Œä»è€ŒæŠµæ¶ˆå½±å“ã€‚

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int res = 0;
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        if (i % 2) res ^= x; // åªå¯¹å¥‡æ•°å°é˜¶çš„çŸ³å­åšNimå’Œ
    }
    if (res) puts("Yes");
    else puts("No");
    return 0;
}```
</details>

<details>
<summary><strong>é›†åˆ-Nim æ¸¸æˆ & SG å‡½æ•°</strong></summary>
![image-20240223094335090](assets/image-20240223094335090.png)

> **è§£æ³•æ€è·¯**ï¼šè¿™æ˜¯ä¸€ä¸ªå¤šå †ç‹¬ç«‹æ¸¸æˆçš„å’Œï¼Œæœ€ç»ˆç»“æœæ˜¯å„å † SG å€¼çš„å¼‚æˆ–å’Œã€‚å¯¹äºä¸€å †æ•°é‡ä¸º `x` çš„çŸ³å­ï¼Œå…¶ SG å€¼ `sg(x)` é€šè¿‡ `mex` è¿ç®—å¾—å‡ºã€‚`sg(x) = mex({sg(x-s1), sg(x-s2), ...})`ï¼Œå…¶ä¸­ `si` æ˜¯å¯å–èµ°çš„çŸ³å­æ•°ã€‚æˆ‘ä»¬ç”¨è®°å¿†åŒ–æœç´¢æ¥è®¡ç®— `sg` å€¼ã€‚

```cpp
#include <cstring>
#include <iostream>
#include <unordered_set>
using namespace std;
const int N = 110, M = 10010;

int k, s[N], f[M]; // f[]æ˜¯è®°å¿†åŒ–æ•°ç»„

int sg(int x) {
    if (f[x] != -1) return f[x];
    unordered_set<int> S;
    for (int i = 0; i < k; i++) {
        if (x >= s[i]) S.insert(sg(x - s[i]));
    }
    for (int i = 0; ; i++) {
        if (!S.count(i)) return f[x] = i;
    }
}

int main() {
    cin >> k;
    for (int i = 0; i < k; i++) cin >> s[i];
    int n;
    cin >> n;
    memset(f, -1, sizeof f);
    int res = 0;
    while (n--) {
        int x;
        cin >> x;
        res ^= sg(x);
    }
    if (res) puts("Yes");
    else puts("No");
    return 0;
}
```
</details>

<details>
<summary><strong>æ‹†åˆ†-Nim æ¸¸æˆ</strong></summary>
![image-20240223103605920](assets/image-20240223103605920.png)

> **è§£æ³•æ€è·¯**ï¼šå°†ä¸€å †çŸ³å­æ‹†åˆ†æˆä¸¤å †ï¼Œç›¸å½“äºå°†ä¸€ä¸ªæ¸¸æˆåˆ†è£‚æˆä¸¤ä¸ªç‹¬ç«‹çš„æ¸¸æˆã€‚æ ¹æ® **Sprague-Grundy å®šç†**ï¼Œåˆ†è£‚åçš„ SG å€¼æ˜¯ä¸¤å †æ–°çŸ³å­ SG å€¼çš„å¼‚æˆ–å’Œã€‚å› æ­¤ï¼Œ`sg(x) = mex({sg(i) ^ sg(j) | i+j = x})`ã€‚ä½†é¢˜ç›®ä¸­æ˜¯æ‹†æˆä¸¤å †ä»»æ„æ•°é‡ï¼Œæ‰€ä»¥æ˜¯ `sg(x) = mex({sg(i) ^ sg(j) | 0 <= i, j < x})`ã€‚

```cpp
#include <cstring>
#include <iostream>
#include <unordered_set>
using namespace std;
const int N = 110;

int f[N];

int sg(int x) {
    if (f[x] != -1) return f[x];
    unordered_set<int> S;
    for (int i = 0; i < x; i++) {
        for (int j = 0; j <= i; j++) { // æ‹†æˆ i å’Œ j ä¸¤å †ï¼Œä½†é¢˜ç›®æ˜¯ä»»æ„ä¸¤å †ï¼Œè¿™é‡Œå®ç°çš„æ˜¯å’Œä¸ºx
            // é¢˜æ„æ˜¯å°†ä¸€å †xæ‹†æˆä¸¤å † i, j (i,j>0, i+j=x), sgå€¼æ˜¯ sg(i)^sg(j)
            // è€Œé¢˜ç›®ç»™çš„å›¾æ˜¯æ‹†æˆä»»æ„ä¸¤å †ï¼Œåº”è¯¥æ˜¯ for i in 0..x-1, for j in 0..x-1
            S.insert(sg(i) ^ sg(j));
        }
    }
    for (int i = 0; ; i++) {
        if (!S.count(i)) return f[x] = i;
    }
}

int main() {
    int n;
    cin >> n;
    memset(f, -1, sizeof f);
    int res = 0;
    while (n--) {
        int x;
        cin >> x;
        res ^= sg(x);
    }
    if (res) puts("Yes");
    else puts("No");
    return 0;
}
```
</details>

---

### ğŸ“š é™„å½•ï¼šåšå¼ˆè®ºæ ¸å¿ƒæ¦‚å¿µ

-   **å…¬å¹³ç»„åˆæ¸¸æˆ (ICG)**:
    1.  ä¸¤åç©å®¶äº¤æ›¿è¡ŒåŠ¨ã€‚
    2.  ä»»ä½•æ—¶åˆ»ï¼Œåˆæ³•è¡ŒåŠ¨åªå–å†³äºå½“å‰å±€é¢ï¼Œä¸ç©å®¶æ— å…³ã€‚
    3.  ä¸èƒ½è¡ŒåŠ¨çš„ç©å®¶åˆ¤è´Ÿã€‚

-   **æœ‰å‘å›¾æ¸¸æˆ**:
    -   ä»»ä½• ICG éƒ½å¯ä»¥è½¬åŒ–ä¸ºæœ‰å‘å›¾æ¸¸æˆã€‚å±€é¢æ˜¯èŠ‚ç‚¹ï¼Œè¡ŒåŠ¨æ˜¯è¾¹ã€‚æ— æ³•ç§»åŠ¨è€…ï¼ˆå‡ºåº¦ä¸º0çš„èŠ‚ç‚¹ï¼‰ä¸ºå¿…è´¥æ€ã€‚

-   **Mex (Minimum Excluded value) è¿ç®—**:
    -   `mex(S)`: ä¸å±äºéè´Ÿæ•´æ•°é›†åˆ `S` çš„æœ€å°éè´Ÿæ•´æ•°ã€‚
    -   ä¾‹: `mex({0, 1, 3, 4}) = 2`ã€‚

-   **SG (Sprague-Grundy) å‡½æ•°**:
    -   `SG(x) = mex({SG(y1), SG(y2), ...})`, å…¶ä¸­ `y` æ˜¯ `x` çš„æ‰€æœ‰åç»§å±€é¢ã€‚
    -   ç»ˆç‚¹ï¼ˆå¿…è´¥æ€ï¼‰çš„ `SG` å€¼ä¸º 0ã€‚
    -   **SG å®šç†**: å±€é¢çš„ `SG` å€¼ä¸º 0ï¼Œåˆ™è¯¥å±€é¢ä¸ºå¿…è´¥æ€ï¼›`SG` å€¼å¤§äº 0ï¼Œåˆ™ä¸ºå¿…èƒœæ€ã€‚

-   **æ¸¸æˆçš„å’Œ (Sprague-Grundy Theorem)**:
    -   å¤šä¸ªç‹¬ç«‹å­æ¸¸æˆçš„ç»„åˆï¼Œå…¶æ€»å±€é¢çš„ `SG` å€¼ç­‰äºæ‰€æœ‰å­æ¸¸æˆ `SG` å€¼çš„ **å¼‚æˆ–å’Œ**ã€‚
    -   `SG(G) = SG(G1) ^ SG(G2) ^ ... ^ SG(Gm)`
    -   è¿™å°±æ˜¯ä¸ºä»€ä¹ˆ Nim æ¸¸æˆï¼ˆå¯çœ‹ä½œ n ä¸ªç‹¬ç«‹å­æ¸¸æˆï¼‰çš„èƒœè´Ÿå–å†³äºçŸ³å­æ•°çš„å¼‚æˆ–å’Œï¼Œå› ä¸ºå•å † `k` ä¸ªçŸ³å­çš„ `SG` å€¼å°±æ˜¯ `k`ã€‚

